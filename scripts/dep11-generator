#!/usr/bin/env python3
#
# Copyright (C) 2015 Matthias Klumpp <mak@debian.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3.0 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program.

import os
import sys
import yaml
import apt_pkg
import gzip
import tarfile
import glob
import shutil
import time
from jinja2 import Environment, FileSystemLoader
from kyotocabinet import *
from optparse import OptionParser
from dep11.multiprocessing import *
import multiprocessing as mp
import logging as log

from dep11.extractor import MetadataExtractor
from dep11.component import DEP11Component, DEP11YamlDumper, get_dep11_header
from dep11.iconfinder import ContentsListIconFinder
from dep11.utils import read_packages_dict_from_file
from dep11.hints import get_hint_tag_info

def safe_move_file(old_fname, new_fname):
    if not os.path.isfile(old_fname):
        return
    if os.path.isfile(new_fname):
        os.remove(new_fname)
    os.rename(old_fname, new_fname)


def no_epoch(version):
    v = version
    if ":" in v:
        return v[v.index(":")+1:]
    else:
        return v


def get_pkg_id(name, version, arch):
    ver = no_epoch(version)
    return "%s_%s_%s" % (name, ver, arch)


class MetadataPool:
    '''
    A pool of component metadata
    '''

    def __init__(self, db, hints_db):
        '''
        Initialize the metadata pool.
        '''
        self._mcpts = dict()
        self._db = db
        self._db_hints = hints_db


    def append_cptdata(self, pkgname, version, arch, cptlist):
        '''
        Makes a list of all the DEP11Component objects in a arch pool
        '''
        cpts = self._mcpts.get(arch)
        if not cpts:
            self._mcpts[arch] = list()
            cpts = self._mcpts[arch]
        for c in cptlist:
            cpts.append({'version': version, 'cpt': c, 'pkg': pkgname})
        if not cptlist:
            cpts.append({'version': version, 'cpt': None, 'pkg': pkgname})


    def save(self):
        """
        Saves metadata in db (serialized to YAML)
        """

        self._db.begin_transaction()
        self._db_hints.begin_transaction()

        for arch, items in self._mcpts.items():
            for item in items:
                cpt = item.get('cpt')
                version = item['version']
                pkid = get_pkg_id(item['pkg'], version, arch)

                # if the package has no components, mark it as always-ignored
                if not cpt:
                    self._db_hints.set(pkid, "ignore")
                    continue

                # get the metadata in YAML format
                metadata = cpt.to_yaml_doc()
                hints_yml = cpt.get_hints_yaml()
                if not hints_yml:
                    hints_yml = ""

                if not cpt.has_ignore_reason():
                    self._db.set(pkid, metadata)
                self._db_hints.set(pkid, hints_yml)

        self._db.end_transaction()
        self._db_hints.end_transaction()


def extract_metadata(mde, sn, pkgname, package_fname, version, arch):
    cpts = mde.process(pkgname, package_fname)

    data = dict()
    data['arch'] = arch
    data['cpts'] = list(cpts)
    data['version'] = version
    data['pkgname'] = pkgname
    data['message'] = "Processed package: %s (%s/%s)" % (pkgname, sn, arch)

    return (PROC_STATUS_SUCCESS, data)


class DEP11Generator:
    def __init__(self):
        pass


    def initialize(self, dep11_dir):
        dep11_dir = os.path.abspath(dep11_dir)

        conf_fname = os.path.join(dep11_dir, "dep11-config.yml")
        if not os.path.isfile(conf_fname):
            print("Could not find configuration! Make sure 'dep11-config.yml' exists!")
            return False

        f = open(conf_fname, 'r')
        conf = yaml.safe_load(f.read())
        f.close()

        if not conf:
            print("Configuration is empty!")
            return False

        if not conf.get("ArchiveRoot"):
            print("You need to specify an archive root path.")
            return False

        if not conf.get("Suites"):
            print("Config is missing information about suites!")
            return False

        if not conf.get("AssetsUrl"):
            print("You need to specify an URL where additional data (like screenshots) can be downloaded.")
            return False

        self._dep11_url = conf.get("AssetsUrl")
        self._icon_sizes = conf.get("IconSizes")
        if not self._icon_sizes:
            self._icon_sizes = ["128x128", "64x64"]

        self._archive_root = conf.get("ArchiveRoot")

        self._cache_dir = os.path.join(dep11_dir, "cache")
        if conf.get("CacheDir"):
            self._cache_dir = conf.get("CacheDir")

        self._export_dir = os.path.join(dep11_dir, "export")
        if conf.get("ExportDir"):
            self._export_dir = conf.get("ExportDir")

        if not os.path.exists(self._cache_dir):
            os.makedirs(self._cache_dir)
        if not os.path.exists(self._export_dir):
            os.makedirs(self._export_dir)

        self._suites_data = conf['Suites']

        self._db = DB()
        if not self._db.open(os.path.join(self._cache_dir, "data_cache.kch"), DB.OREADER | DB.OWRITER | DB.OCREATE):
            log.error("Could not open cache: %s" % (str(self._db.error())), file=sys.stderr)
            return False

        self._db_hints = DB()
        if not self._db_hints.open(os.path.join(self._cache_dir, "hints_cache.kch"), DB.OREADER | DB.OWRITER | DB.OCREATE):
            log.error("Could not open hints cache: %s" % (str(self._db_hints.error())), file=sys.stderr)
            return False

        self._hints_html_url = conf.get("HintsHtmlUrl")
        if not self._hints_html_url:
            self._hints_html_url = "."

        template_dir = os.path.dirname(os.path.realpath(__file__))
        template_dir = os.path.realpath(os.path.join(template_dir, "..", "data", "templates", "default"))
        if not os.path.isdir(template_dir):
            template_dir = os.path.join(sys.prefix, "share", "dep11", "templates")

        self._template_dir = template_dir

        self._distro_name = conf.get("DistroName")
        if not self._distro_name:
            self._distro_name = "Debian"

        os.chdir(dep11_dir)
        return True


    def _get_asset_dir(self):
        asset_dir = os.path.join(self._export_dir, "assets")
        if not os.path.exists(asset_dir):
            os.makedirs(asset_dir)
        return asset_dir


    def _get_packages_for(self, suite, component, arch):
        return read_packages_dict_from_file(self._archive_root, suite, component, arch).values()


    def make_icon_tar(self, suitename, component, pkglist):
        '''
         Generate icons-%(size).tar.gz
        '''
        dep11_assetdir = self._get_asset_dir()
        names_seen = set()
        tar_location = os.path.join(self._export_dir, "dep11", suitename, component)

        size_tars = dict()

        for pkg in pkglist:
            pkid = get_pkg_id(pkg['name'], pkg['version'], pkg['arch'])

            for size in self._icon_sizes:
                icon_location_glob = os.path.join (dep11_assetdir, component, pkid, "icons", size, "*.*")

                tar = None
                if size not in size_tars:
                    icon_tar_fname = os.path.join(tar_location, "icons-%s.tar.gz" % (size))
                    size_tars[size] = tarfile.open(icon_tar_fname+".new", "w:gz")
                tar = size_tars[size]

                for filename in glob.glob(icon_location_glob):
                    icon_name = os.path.basename(filename)
                    if icon_name in names_seen:
                        continue
                    tar.add(filename, arcname=icon_name)
                    names_seen.add(icon_name)

        for tar in size_tars.values():
            tar.close()
            # FIXME Ugly....
            safe_move_file(tar.name, tar.name.replace(".new", ""))


    def _expire_asset(self, pkid):
        dep11_assetdir = self._get_asset_dir()
        dirs = glob.glob(os.path.join(dep11_assetdir, "*", str(pkid)))
        if dirs:
            shutil.rmtree(dirs[0])
            log.debug("Expired: %s" % (os.path.basename(dirs[0])))


    def process_suite(self, suite_name):
        '''
        Extract new metadata for a given suite.
        '''

        suite = self._suites_data.get(suite_name)
        if not suite:
            log.error("Suite '%s' not found!" % (suite_name))
            return False

        dep11_assetdir = self._get_asset_dir()

        # We need 'forkserver' as startup method to prevent deadlocks on join()
        # Something in the extractor is doing weird things, makes joining impossible
        # when using simple fork as startup method.
        mp.set_start_method('forkserver')

        for component in suite['components']:
            all_cpt_pkgs = list()
            for arch in suite['architectures']:
                pkglist = self._get_packages_for(suite_name, component, arch)

                pool = ExtractorProcessPool(maxtasksperchild=16)
                dpool = MetadataPool(self._db, self._db_hints)

                def parse_results(message):
                    (code, msg) = message
                    if code != PROC_STATUS_SUCCESS:
                        log.error(str(msg))
                        pool.terminate()
                        # FIXME: Joining doesn't work, we need a smarter way to terminate on error
                        # pool.join()
                        sys.exit(5)
                    log.info(msg['message'])
                    dpool.append_cptdata(msg['pkgname'], msg['version'], msg['arch'], msg['cpts'])

                iconf = ContentsListIconFinder(suite_name, component, arch, self._archive_root)
                mde = MetadataExtractor(suite_name, component,
                                dep11_assetdir,
                                self._dep11_url,
                                self._icon_sizes,
                                iconf)

                for pkg in pkglist:
                    package_fname = os.path.join (self._archive_root, pkg['filename'])
                    pkid = get_pkg_id(pkg['name'], pkg['version'], pkg['arch'])

                    # check if we scanned the package already
                    if self._db.get_str(pkid) or self._db_hints.get_str(pkid):
                        continue

                    if not os.path.exists(package_fname):
                        log.warning('Package not found: %s' % (package_fname))
                        continue
                    pool.apply_async(extract_metadata,
                                (mde, suite_name, pkg['name'], package_fname, pkg['version'], pkg['arch']), callback=parse_results)
                pool.close()
                pool.join()

                # save new metadata to the database
                dpool.save()

                hints_dir = os.path.join(self._export_dir, "hints", suite_name, component)
                if not os.path.exists(hints_dir):
                    os.makedirs(hints_dir)
                dep11_dir = os.path.join(self._export_dir, "dep11", suite_name, component)
                if not os.path.exists(dep11_dir):
                    os.makedirs(dep11_dir)

                # now write data to disk
                hints_fname = os.path.join(hints_dir, "DEP11Hints_%s.yml.gz" % (arch))
                data_fname = os.path.join(dep11_dir, "Components-%s.yml.gz" % (arch))

                hints_f = gzip.open(hints_fname+".new", 'wb')
                data_f = gzip.open(data_fname+".new", 'wb')

                dep11_header = get_dep11_header(suite_name, component)
                data_f.write(bytes(dep11_header, 'utf-8'))

                for pkg in pkglist:
                    pkid = get_pkg_id(pkg['name'], pkg['version'], pkg['arch'])
                    data = self._db.get_str(pkid)
                    if data:
                        data_f.write(bytes(data, 'utf-8'))
                    hint = self._db_hints.get_str(pkid)
                    if hint and hint != "ignore":
                        hints_f.write(bytes(hint, 'utf-8'))

                data_f.close()
                safe_move_file(data_fname+".new", data_fname)

                hints_f.close()
                safe_move_file(hints_fname+".new", hints_fname)

                all_cpt_pkgs.extend(pkglist)

            # create icon tarball
            self.make_icon_tar(suite_name, component, all_cpt_pkgs)

            log.info("Completed metadata extraction for suite %s/%s" % (suite_name, component))


    def expire_cache(self):
        pkgids = set()
        for suite_name in self._suites_data:
            suite = self._suites_data[suite_name]
            for component in suite['components']:
                for arch in suite['architectures']:
                    pkglist = self._get_packages_for(suite_name, component, arch)
                    for pkg in pkglist:
                        pkid = get_pkg_id(pkg['name'], pkg['version'], pkg['arch'])
                        pkgids.add(str(pkid))

        # clean caches and database
        for pkid in self._db:
            if str(pkid) in pkgids:
                continue
            self._db.remove(pkid)
            self._expire_asset(pkid)

        for pkid in self._db_hints:
            if str(pkid) in pkgids:
                continue
            self._db_hints.remove(pkid)
            self._expire_asset(pkid)


    def render_template(self, name, out_dir, out_name = None, *args, **kwargs):
        if not out_name:
            out_path = os.path.join(out_dir, name)
        else:
            out_path = os.path.join(out_dir, out_name)
        # create subdirectories if necessary
        out_dir = os.path.dirname(os.path.realpath(out_path))
        if not os.path.exists(out_dir):
            os.makedirs(out_dir)

        j2_env = Environment(loader=FileSystemLoader(self._template_dir))

        template = j2_env.get_template(name)
        content = template.render(root_url=self._hints_html_url, distro=self._distro_name,
                                    time=time.strftime("%Y-%m-%d %H:%M:%S %Z"), *args, **kwargs)
        log.debug("Render: %s" % (out_path))
        with open(out_path, 'wb') as f:
            f.write(bytes(content, 'utf-8'))


    def _expand_hint(self, hint_data):
        tag_name = hint_data['tag']
        tag = get_hint_tag_info(tag_name)

        desc = ""
        try:
            desc = tag['text'] % hint_data['params']
        except Exception as e:
            desc = "Error while expanding hint description: %s" % (str(e))

        severity = tag.get('severity')
        if not severity:
            log.error("Tag %s has no severity!", tag_name)
            severity = "info"

        return {'tag_name': tag_name, 'description': desc, 'severity': severity}


    def update_html(self):
        dep11_hintsdir = os.path.join(self._export_dir, "hints")
        if not os.path.exists(dep11_hintsdir):
            return

        export_dir = os.path.join(self._export_dir, "hints_html")
        # Render archive suites index page
        self.render_template("suites_index.html", export_dir, "index.html", suites=self._suites_data.keys())

        # FIXME: Properly account for architecture, and remove old HTML files
        for suite_name in self._suites_data:
            suite = self._suites_data[suite_name]
            export_dir = os.path.join(self._export_dir, "hints_html", suite_name)
            # Render archive components index page
            self.render_template("sections_index.html", export_dir, "index.html",
                            sections=suite['components'], suite=suite_name)

            for component in suite['components']:
                for arch in suite['architectures']:
                    package_summaries = dict()
                    export_dir = os.path.join(self._export_dir, "hints_html", suite_name, component)
                    h_fname = os.path.join(dep11_hintsdir, suite_name, component, "DEP11Hints_%s.yml.gz" % (arch))
                    if not os.path.isfile(h_fname):
                        continue
                    f = gzip.open(h_fname, 'r')
                    hints_data = yaml.safe_load_all(f.read())
                    f.close()
                    if not hints_data:
                        continue

                    packages_list = self._get_packages_for(suite_name, component, arch)
                    pkg_maintainer = dict()
                    for pkg in packages_list:
                        pkg_maintainer[pkg['name']] = pkg['maintainer']

                    for hint in hints_data:
                        pkg_name = hint['Package']
                        maintainer = pkg_maintainer.get(pkg_name)
                        if not maintainer:
                            maintainer = "Unknown"
                        if not package_summaries.get(maintainer):
                            package_summaries[maintainer] = list()
                        hints_raw = hint.get('Hints', list())

                        # expand all hints to show long descriptions
                        errors = list()
                        warnings = list()
                        infos = list()

                        for hint in hints_raw:
                            ehint = self._expand_hint(hint)
                            severity = ehint['severity']
                            if severity == "info":
                                infos.append(ehint)
                            elif severity == "warning":
                                warnings.append(ehint)
                            else:
                                errors.append(ehint)

                        # add info for global index
                        package_summaries[maintainer].append({'pkgname': pkg_name, 'errors_count': len(errors), 'warnings_count': len(warnings), 'infos_count': len(infos)})

                        # render page
                        self.render_template("issues_page.html", export_dir, "%s.html" % (pkg_name),
                                package_name=pkg_name, errors=errors, warnings=warnings, infos=infos, suite=suite_name, section=component)

                    # Now render our index page
                    self.render_template("issues_index.html", export_dir, "index.html",
                                package_summaries=package_summaries, suite=suite_name, section=component)

        # Copy the static files
        target_static_dir = os.path.join(self._export_dir, "hints_html", "static")
        shutil.rmtree(target_static_dir, ignore_errors=True)
        shutil.copytree(os.path.join(self._template_dir, "static"), target_static_dir)


    def remove_processed(self, suite_name):
        '''
        Delete information about processed packages, to later reprocess them.
        '''

        suite = self._suites_data.get(suite_name)
        if not suite:
            log.error("Suite '%s' not found!" % (suite_name))
            return False

        for component in suite['components']:
            all_cpt_pkgs = list()
            for arch in suite['architectures']:
                pkglist = self._get_packages_for(suite_name, component, arch)

                for pkg in pkglist:
                    package_fname = os.path.join (self._archive_root, pkg['filename'])
                    pkid = get_pkg_id(pkg['name'], pkg['version'], pkg['arch'])

                    # we ignore packages without any interesting metadata here
                    hint = self._db_hints.get_str(pkid)
                    if str(hint) == "ignore":
                        continue

                    self._db_hints.remove(pkid)
                    self._db.remove(pkid)
                    self._expire_asset(pkid)


def main():
    parser = OptionParser()

    (options, args) = parser.parse_args()
    if len(args) == 0:
        print("You need to specify a command!")
        sys.exit(1)

    command = args[0]

    # configure logging
    log_level = log.INFO
    if os.environ.get("DEBUG"):
        log_level = log.DEBUG
    log.basicConfig(format='%(asctime)s - %(levelname)s: %(message)s', level=log_level)

    if command == "process":
        if len(args) != 3:
            print("You need to specify a DEP-11 data dir and a suite.")
            sys.exit(1)
        gen = DEP11Generator()
        ret = gen.initialize(args[1])
        if not ret:
            print("Initialization failed, can not continue.")
            sys.exit(2)

        gen.process_suite(args[2])
    elif command == "cleanup":
        if len(args) != 2:
            print("You need to specify a DEP-11 data dir.")
            sys.exit(1)
        gen = DEP11Generator()
        ret = gen.initialize(args[1])
        if not ret:
            print("Initialization failed, can not continue.")
            sys.exit(2)

        gen.expire_cache()
    elif command == "update-html":
        if len(args) != 2:
            print("You need to specify a DEP-11 data dir.")
            sys.exit(1)
        gen = DEP11Generator()
        ret = gen.initialize(args[1])
        if not ret:
            print("Initialization failed, can not continue.")
            sys.exit(2)

        gen.update_html()
    elif command == "remove-processed":
        if len(args) != 3:
            print("You need to specify a DEP-11 data dir and suite.")
            sys.exit(1)
        gen = DEP11Generator()
        ret = gen.initialize(args[1])
        if not ret:
            print("Initialization failed, can not continue.")
            sys.exit(2)

        gen.remove_processed(args[2])
    else:
        print("Run with --help for a list of available command-line options!")


if __name__ == "__main__":
    apt_pkg.init()
    main()
